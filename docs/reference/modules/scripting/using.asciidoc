[[modules-scripting-using]]
=== 如何使用脚本

在 ElasticSearch API 中支持脚本的地方，语法都如以下模式：

[source,js]
-------------------------------------
  "script": {
    "lang":   "...",  <1>
    "source" | "id": "...", <2>
    "params": { ... } <3>
  }
-------------------------------------
// NOTCONSOLE
<1> 脚本所使用的语言，默认为 `painless`。
<2> 可被指定为 `source` 的行内脚本自身或存储的脚本的 `id`。
<3> 应传给脚本的任何命名参数。

例如，以下在查询请求中的脚本用来返回一个<<search-request-script-fields, 脚本字段>>：

[source,js]
-------------------------------------
PUT my_index/_doc/1
{
  "my_field": 5
}

GET my_index/_search
{
  "script_fields": {
    "my_doubled_field": {
      "script": {
        "lang":   "expression",
        "source": "doc['my_field'] * multiplier",
        "params": {
          "multiplier": 2
        }
      }
    }
  }
}
-------------------------------------
// CONSOLE

[float]
=== 脚本参数

`lang`::

    指定写脚本所用的语言。默认为 `painless`。


`source`, `id`::

    指定脚本来源。上例中一个 `inline` 脚本被指定为 `source`。一个 `存储` 脚本可被指定为 `id` 并能从集群状态中检索（查看 <<modules-scripting-stored-scripts,存储脚本>>）。


`params`::

    指定传到脚本中作为变量的任何命名参数。

[IMPORTANT]
[[prefer-params]]
.首选参数
========================================

Elasticsearch 首次见到一个新脚本时，它编译并存储已编译版本到缓存中。编译可能是一个繁重的过程。

如果需要将变量传递到脚本中，则应将它们作为命名 `参数`，而不是将值硬编码到脚本本身。
例如，如果要将字段值乘以乘数，不要将乘数硬编码到脚本中：

[source,js]
----------------------
  "source": "doc['my_field'] * 2"
----------------------
// NOTCONSOLE

相反，将其作为命名参数传入：

[source,js]
----------------------
  "source": "doc['my_field'] * multiplier",
  "params": {
    "multiplier": 2
  }
----------------------
// NOTCONSOLE

第一个版本必须在每次乘数更改时重新编译。第二个版本只编译一次。

如果在很短的时间内编译了太多的惟一脚本，ElasticSearch 将抛出 `电路断开异常` 错误，拒绝新的动态脚本。默认情况下，每分钟最多15个行内脚本。可动态设置 `script.max_compilations_rate` 来更改此设置。

========================================

[float]
[[modules-scripting-short-script-form]]
=== 短脚本格式
为了简洁起见，可以使用简短的脚本形式。在短格式中，`脚本` 由字符串而不是对象表示。此字符串包含脚本来源。

短格式：

[source,js]
----------------------
  "script": "ctx._source.likes++"
----------------------
// NOTCONSOLE

在普通格式中的同样脚本：

[source,js]
----------------------
  "script": {
    "source": "ctx._source.likes++"
  }
----------------------
// NOTCONSOLE

[float]
[[modules-scripting-stored-scripts]]
=== 存储脚本

脚本可以存储到集群状态中，并使用 `_scripts` 端点从中检索。

==== 请求样例

以下是使用在 `/_scripts/{id}` 中的存储脚本的例子。

首先，创建一个叫做 `calculate-score` 的脚本到集群状态中：

[source,js]
-----------------------------------
POST _scripts/calculate-score
{
  "script": {
    "lang": "painless",
    "source": "Math.log(_score * 2) + params.my_modifier"
  }
}
-----------------------------------
// CONSOLE

该脚本可这样检索：

[source,js]
-----------------------------------
GET _scripts/calculate-score
-----------------------------------
// CONSOLE
// TEST[continued]

存储脚本可通过指定 `id` 参数来使用，如下：

[source,js]
--------------------------------------------------
GET _search
{
  "query": {
    "script": {
      "script": {
        "id": "calculate-score",
        "params": {
          "my_modifier": 2
        }
      }
    }
  }
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

删除脚本:

[source,js]
-----------------------------------
DELETE _scripts/calculate-score
-----------------------------------
// CONSOLE
// TEST[continued]

[float]
[[modules-scripting-using-caching]]
=== 脚本缓存

所有脚本都默认被缓存，因此只有更新时需要重新编译它们。默认情况下，脚本没有基于时间的过期期限，但可以使用 `script.cache.expire` 设置更改此行为。可以使用 `script.cache.max` 设置配置此缓存的大小。默认情况下，缓存大小为 `100`。

NOTE: 存储脚本的大小限制为65535字节。这可以通过设置 `script.max_size_in_bytes` 来更改，以增加软性限制，但如果脚本非常大，则应考虑使用<<modules-scripting-engine,本地脚本引擎>>。