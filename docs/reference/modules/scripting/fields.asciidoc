[[modules-scripting-fields]]
=== 访问文档字段和特殊变量

根据脚本的使用位置，它可以访问特定的变量和文档字段。

[float]
== 更新脚本

在<<docs-update,update>>，<<docs-update-by-query,update-by-query>> 或 <<docs-reindex,reindex>> API 中使用的脚本可以访问 `ctx` 变量：

[horizontal]
`ctx._source`::     访问文档的 <<mapping-source-field,`_source` 字段>>。
`ctx.op`::          应用到文档的操作：`index` 或 `delete`。
`ctx._index` 等::  访问<<mapping-fields,文档元字段>>，其中有些是只读的。

[float]
== 查询和聚合脚本

除<<search-request-script-fields,脚本字段>>是每次搜索命中执行一次外，搜索和聚合中使用的脚本将对可能匹配查询或聚合的每个文档执行一次。根据文档数量，这可能意味着数百万或数十亿执行：这些脚本必须跑得飞快！

使用 <<modules-scripting-doc-vals,doc-values>> 或者<<modules-scripting-stored,存储字段 或 `_source` 字段>>可以从脚本中访问字段值，其解释如下。

[[scripting-score]]
[float]
=== 在脚本中访问文档的分数

在<<query-dsl-function-score-query,`function_score` 查询>>，<<search-request-sort,基于脚本的排序>>或者<<search-aggregations,聚合>>中使用的脚本，可以访问 `_score` 变量，它代表一个文档的当前相关性得分。

以下是在<<query-dsl-function-score-query,`function_score` 查询>>中使用脚本来更改每个文档的相关性 `_score` 的例子：

[source,js]
-------------------------------------
PUT my_index/_doc/1?refresh
{
  "text": "quick brown fox",
  "popularity": 1
}

PUT my_index/_doc/2?refresh
{
  "text": "quick fox",
  "popularity": 5
}

GET my_index/_search
{
  "query": {
    "function_score": {
      "query": {
        "match": {
          "text": "quick brown fox"
        }
      },
      "script_score": {
        "script": {
          "lang": "expression",
          "source": "_score * doc['popularity']"
        }
      }
    }
  }
}
-------------------------------------
// CONSOLE


[float]
[[modules-scripting-doc-vals]]
=== 文档值

到目前为止，从脚本中访问一个字段值的最高效的方法是使用 `doc['field_name']` 语法，该语法用于检索字段来自<<doc-values,文档值>>的值。文档值是列字段值存储，默认情况下在除<<text,分词的 `text` 字段>>之外的所有字段上启用。

[source,js]
-------------------------------
PUT my_index/_doc/1?refresh
{
  "cost_price": 100
}

GET my_index/_search
{
  "script_fields": {
    "sales_price": {
      "script": {
        "lang":   "expression",
        "source": "doc['cost_price'] * markup",
        "params": {
          "markup": 0.2
        }
      }
    }
  }
}
-------------------------------
// CONSOLE

文档值只能返回 `简单` 的字段值如数值、日期、地理点、词等，或者如果该字段包含多值的话则是这些值组成的数组。它无法返回 JSON 对象。

[NOTE]
.缺失的字段
===================================================

如果 mappings 中 `field` 是缺失的， `doc['field']` 将会跑出一个错误。在 `painless` 中，会先用 `doc.containsKey('field')` 运行一个检查来确保访问 `doc` 映射。然而不幸的是，在 `表达式` 脚本中无法检查字段在 mappings 是否存在。

===================================================

[NOTE]
.文档值和 `text` 字段
===================================================

如果<<fielddata,`字段数据`>>被启用，`doc['field']` 语法也能用于<<text,分词的 `text` 字段>>，但需 *注意* ：在 `text` 上启用字段数据要求加载所有词到 JVM 堆中，这对内存和 CPU 都是很昂贵的开销。从脚本中访问 `text` 字段通常没什么意义。

===================================================

[float]
[[modules-scripting-stored]]
=== 存储字段和 `_source`

_存储字段_ -- 明确标记为<<mapping-store,`"store": true`>>的字段 -- 可用 `_fields['field_name'].value` 或 `_fields['field_name'].values` 语法来访问。

文档的<<mapping-source-field,`_source`>>，它实际上只是一个特殊的存储字段，可以使用 `_source.field_name` 语法访问。`_source` 作为映射的映射而加载，因此对象字段中的属性可以被访问，例如 `_source.name.first`。

[IMPORTANT]
.文档值优先于存储字段
=========================================================

存住字段（包括存储的 `_source` 字段）比文档值慢得多。它们是为每个结果中返回几个字段的优化而来的，而文档值是为访问多个文档的某个特定字段的值而优化的。

当生成一个<<search-request-script-fields,脚本字段>>从查询结果中返回前十个时，使用 `_source` 或 存储字段是合理的。但是对于其他查询和聚合的使用场景，应总是优先使用文档值。

=========================================================


例如：

[source,js]
-------------------------------
PUT my_index
{
  "mappings": {
    "_doc": {
      "properties": {
        "title": { <1>
          "type": "text"
        },
        "first_name": {
          "type": "text",
          "store": true
        },
        "last_name": {
          "type": "text",
          "store": true
        }
      }
    }
  }
}

PUT my_index/_doc/1?refresh
{
  "title": "Mr",
  "first_name": "Barry",
  "last_name": "White"
}

GET my_index/_search
{
  "script_fields": {
    "source": {
      "script": {
        "lang": "painless",
        "source": "params._source.title + ' ' + params._source.first_name + ' ' + params._source.last_name" <2>
      }
    },
    "stored_fields": {
      "script": {
        "lang": "painless",
        "source": "params._fields['first_name'].value + ' ' + params._fields['last_name'].value"
      }
    }
  }
}
-------------------------------
// CONSOLE
<1> 因为 `title` 字段未被存储，所以不能使用 `_fields[]` 语法。
<2> `title` 字段依然可以从 `_source` 中访问。

[TIP]
.存储 vs `_source`
=======================================================

`_source` 字段仅仅是一个特殊的存储的字段，所以性能和其他存储字段相似。`_source` 提供了访问被索引的原始文档的方法（包括区分 `null` 值和空白字段，单值数组和简单标量的能力等）。

唯一真正有意义的使用存储字段而不用 `_source` 字段的时机是，`_source` 字段过于庞大并且访问个别小的存储字段相较于整个 `_source` 成本较低的时候。

=======================================================
