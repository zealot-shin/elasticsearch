[[modules-threadpool]]
== 线程池

一个节点有数个线程池来优化节点内线程的内存消耗的管理。其中多数线程池都有自身的队列，可用来存放排队中的请求而不用丢弃它们。

在这许多线程池中，最重要的几个包括：

`generic`::
    用于通用操作（比如后台的节点发现）。线程池类型是 `scaling`。

`index`::
    用于 index/delete 操作。线程池类型为 `fixed`。线程池大小为 `处理器数量`，队列为 `200`。该线程池的最大尺寸为 `1 + 处理器数量`。

`search`::
    用于 count/search/suggest 操作。线程池类型是 `fixed_auto_queue_size`，大小为 `int((处理器数量 * 3) / 2) + 1`，默认队列长度为 `1000`。

`get`::
    用于 get 操作。线程池类型是 `fixed`，大小为 `处理器数量`，队列大小为 `1000`。

`analyze`::
    用于 analyze 请求。线程池类型为 `fixed`，大小为1，队列大小为16。

`write`::
    用于单个文档的 index/delete/update 以及 bulk 请求。线程池类型为 `fixed`，大小为 `处理器数量`，队列大小为 `200`。最大线程数是 `1 + 处理器数量`。

`snapshot`::
    用于 snapshot/restore 操作。线程池类型是 `scaling`，线程保持存活时间为 `5m`，最大线程数为 `min(5, (处理器数量)/2)`。

`warmer`::
    用于 segment warm-up 操作。线程池类型为 `scaling`，保持存活时间为 `5m`，最大线程数为 `min(5, (处理器数量)/2)`。

`refresh`::
    用于 refresh 操作。线程池类型为 `scaling`，保持存活时间为 `5m`，最大线程数是 `min(10, (处理器数量)/2)`。

`listener`::
    主要用于 Java 客户端县城监听器被设置为 true 时执行动作。线程池类型为 `scaling`，默认最大线程数为 `min(10, (处理器数量)/2)`。

通过配置线程池的类型指定参数可以改变特定线程池；例如，更改 `index` 线程池来拥有更多的线程数：

[source,yaml]
--------------------------------------------------
thread_pool:
    index:
        size: 30
--------------------------------------------------

[float]
[[types]]
=== 线程池类型

以下是线程池的各个类型和它们的参数：

[float]
==== `fixed`

`fixed` 线程池拥有固定数量的线程来处理请求，对于无可用线程的请求，将被添加到（可选的有界）中队列等待。

`size` 参数用来控制线程的数量，默认为核数乘以5。

`queue_size` 参数用来控需要等待的任务队列大小。默认为 `-1` 表示无限制。当请求达到时，如果队列已满，则请求将被拒绝。

[source,yaml]
--------------------------------------------------
thread_pool:
    index:
        size: 30
        queue_size: 1000
--------------------------------------------------

[float]
==== `fixed_auto_queue_size`

实验性[]

`fixed_auto_queue_size` 线程池拥有固定数量的线程来处理请求，以及一个有限长的等待队列。它与 `fixed` 线程池相似，不过其 `队列大小` 将根据https://en.wikipedia.org/wiki/Little%27s_law[利特尔法则（Little's Law）]自动调整。根据该法则，每次 `auto_queue_frame_size` 操作完成时，都可能进行赠减50的 `队列大小` 调整。

`size` 用于指定线程数量，默认为核数乘以5。

`queue_size` 指定初始队列的大小。

`min_queue_size` 指定最小队列大小。

`max_queue_size` 指定最大队列大小。

`auto_queue_frame_size` 指定调整队列大小之前进行测量的操作数。它应该设置得足够大，以免一个单一操作导致过度偏离的计算。

`target_response_time` 设定的时间值，用来指示线程池队列中任务的平均响应时间。如果如无经常高于这个时间，则线程池队列将被调小，以便拒绝任务。

[source,yaml]
--------------------------------------------------
thread_pool:
    search:
        size: 30
        queue_size: 500
        min_queue_size: 10
        max_queue_size: 1000
        auto_queue_frame_size: 2000
        target_response_time: 1s
--------------------------------------------------

[float]
==== `scaling`

`scaling` 线程池拥有动态变化的线程数。线程数和负载成正比，在 `core` 和 `max` 参数之间变化。

`keep_alive` 参数用来控制线程在线程池中的最长空闲时间。

[source,yaml]
--------------------------------------------------
thread_pool:
    warmer:
        core: 1
        max: 8
        keep_alive: 2m
--------------------------------------------------

[float]
[[processors]]
=== 处理器设置
处理数量会被自动探测，各个线程池依据这个数量进行初始化T。某些情况下，手动设置这个参数覆盖掉默认探测的数量也是有用。手动设置可以通过明确配置 `processors` 参数来实现。

[source,yaml]
--------------------------------------------------
processors: 2
--------------------------------------------------

有以下集中场景是需要明确设置 `processors` 数量的：

. 在同一台主机上运行多个 Elasticsearch 实例，但是希望每个实例的线程池只据一部分 CPU 来设置，此时就要通过 `processors` 参数来手动指定为想要的处理器数量。（例如，在16核的服务器上运行2个）实例，把 `processors` 设为8）。注意，这是一个专家级的用例，除设置 `processors` 参数外，还涉及更多其他的配置，如考虑修改 GC 线程数，绑定进程到 CPU 等等。
. 有时候自动探测的处理器数量是错的，那么这种情况必须明确设置 `processors`。

要检查自动探测的处理器数量，可以使用节点信息 API 中的 `os` 字段来查看。

