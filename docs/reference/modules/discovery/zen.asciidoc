[[modules-discovery-zen]]
=== Zen 发现

Zen 发现是 Elasticsearch 内建的，默认的发现模块。它提供单播和基于文件的发现，并且可以通过插件扩展以支持云环境和其他形式的发现。

Zen 发现与其他模块集成，例如，所有节点间的通信都使用 <<modules-transport,传输>> 模块完成。

它被分成以下几个子模块：

[float]
[[ping]]
==== Ping

这是一个节点使用发现机制找到其他节点的过程。

[float]
[[discovery-seed-nodes]]
==== 种子节点

Zen 发现使用一个 _种子_ 节点的列表来开始发现的过程。在启动或选举新的主节点时，Elasticsearch 尝试连接列表中每个节点，并且保有一份与各节点间八卦般的会话（gossip-like conversation）来发现其他节点，然后构建一副完整的集群的绘景。默认有2个方法来配置种子节点的列表：_单播_ 和 _基于文件_。建议种子节点列表包含集群中所有主节点。

[float]
[[unicast]]
===== 单播

单播发现配置了一个静态的主机列表作为种子节点。这些主机可指定成域名或者 IP 地址；指定为域名的主机会在每一轮的 ping 期间被解析为 IP 地址。注意如果环境中 DNS 解析随着时间变化，则必须调整 <<networkaddress-cache-ttl,JVM 安全设定>>。

主机列表使用 `discovery.zen.ping.unicast.hosts` 静态设定进行设置。这个参数要么是一个主机的数组，要么是逗号分隔的字符串。每个值都应该是 `主机:端口` 或 `主机` （端口默认为 `transport.profiles.default.port` 的值，如果没设定，则返回 `transport.tcp.port`）的形式。请注意，IPv6主机必须加括号。此设置的默认值为 `127.0.0.1，[：：1]`。

此外，`discovery.zen.ping.unicast.resolve_timeout` 配置了每一轮 ping 中等待 DNS 查找的时间。它被指定为一个<<time-units, 时间单位>>且默认为5s。

单播发现使用 <<modules-transport,传输>> 模块来执行发现。

[float]
[[file-based-hosts-provider]]
===== 基于文件

除了静态设定 `discovery.zen.ping.unicast.hosts` 提供的主机之外，也可以通过外部文件来提供主机列表。Elasticsearch 会在文件更新时重新加载该文件，以便种子节点的列表可以动态更新而无需重启每个节点。例如，对于运行在 Docker 容器中的 Elasticsearch 实例，当节点启动 IP 地址还未知时，这就给了它一个便利的机制来动态地提供一个 IP 地址列表去连接以进行 Zen 发现。

配置如下的提供主机的 `文件` 来激活基于文件的发现：

[source,txt]
----------------------------------------------------------------
discovery.zen.hosts_provider: file
----------------------------------------------------------------

然后在 `$ES_PATH_CONF/unicast_hosts.txt` 创建一个下面描述的格式的文件。每当对 `unicast_hosts.txt` 文件进行更改时，ElasticSearch将获取新更改，并使用新主机列表。

请注意，基于文件发现的插件会把 `elasticsearch.yml` 中的单播主机列表作为参数：如果 `discovery.zen.ping.unicast.hosts` 中存在有效的单播主机入口，那么除 `unicast_hosts.txt` 中提供的以外，这些入口也会被使用。

`discovery.zen.ping.unicast.resolve_timeout` 设定也被用于通过基于文件发现指定地址的节点的 DNS 查找。它被指定为一个<<time-units, 时间单位>>且默认为5s。

文件的格式是每行指定一个节点入口。每个节点入口包含主机（主机名或者 IP 地址）和一个可选的传输端口号。如果指定端口号，必须紧跟在主机（同一行）后面，用 `:` 分隔。如果没有指定端口号，默认使用9300.

例如，以下是一个有四个节点参与单播发现的集群的 `unicast_hosts.txt` 的样例，其中一些并不是运行在默认端口上：

[source,txt]
----------------------------------------------------------------
10.10.10.5
10.10.10.6:9305
10.10.10.5:10005
# an IPv6 address
[2001:0db8:85a3:0000:0000:8a2e:0370:7334]:9301
----------------------------------------------------------------

如果不用 IP 地址设定，主机名也是允许的（类似 `discovery.zen.ping.unicast.hosts`），并且 IPv6 地址必须加括号，同时端口号紧跟在括号后。

文件中也能追加注释。所有的注释必须出现在以 `#` 开始的行（也就是说，注释不能出现在一行的中间）。

[float]
[[master-election]]
==== 主节点选举

作为 ping 过程的一部分，集群中的一个主节点要么被选举出来要么是加入进来。这是自动完成的。`discovery.zen.ping_timeout`（默认 `3s`）决定了在决定开始选举或者加入一个存在的集群之前节点将会等待多长时间。在此超时间隔内将发送三个 ping。如果超时后无法做出决定，则 ping 进程将重新启动。在缓慢或拥挤的网络中，三秒钟可能不足以让节点在做出选举决定之前知晓其环境中的其他节点。在这种情况下，应该小心地增加超时时间，因为这样会减慢选举进程。一旦一个节点决定加入一个已经形成的集群，它将向主节点发送一个加入请求（`discovery.zen.join-timeout`），超时默认为 ping 超时的20倍。

当主节点停止或遇到问题时，群集节点将启动重新 ping 并选举新的主节点。这轮 ping 也是防止（部分）网络故障发生时一个节点可能错误地认为主节点失效的保护措施。在这种情况下，该节点将仅从其他节点处获取当前活跃主节点的信息。

如果 `discovery.zen.master_election.ignore_non_master_pings` 为 `true`，非候选主节点（`node.master` 是 `false` 的节点）的 ping 在主节点选举中会被忽略：默认值是 `false`。

通过设置 `node.master` 为 `false` 可以使节点排除在主节点外。

`discovery.zen.minimum_master_nodes` 设置了候选主节点的最小数目，以完成选举过程并让所选主节点接受其主控权。该设定也控制任何一个活跃集群中包含的最小的活跃候选主节点数。若不满足该要求，活跃主节点将退出并开始选举新的主节点。

此设定必须设置为候选主节点的<<minimum_master_nodes,仲裁数目>>。建议避免只有两个候选主节点，因为2的仲裁数目是2。这样的话，失去任何一个候选主节点将导致群集无法操作。

[float]
[[fault-detection]]
==== 故障检测

存在两种故障检测进程。第一种由主节点运行，用来 ping 所有集群中的其他节点来验证它们在线。第二种则反过来，每个节点 ping 主节点来验证主节点仍然在线否则就需要初始化一个选举过程。

以下使用 `discovery.zen.fd` 为前缀的设定控制故障检测进程：

[cols="<,<",options="header",]
|=======================================================================
|设定 |描述
|`ping_interval` |一个节点被 ping 的频率。默认为 `1s`.

|`ping_timeout` |ping 响应的等待时间，默认为 `30s`.

|`ping_retries` |节点被认为失效的 ping 失败/超时 的次数。默认为 `3`.
|=======================================================================

[float]
==== 集群状态更新

主节点是集群中唯一能改变集群状态的节点。主节点一次处理一个集群状态更新，应用所需的更改并将更新的群集状态发布到群集中的其他节点。每个节点接收发布消息，确认但还不会应用。如果主节点在一个特定的时间内（由 `discovery.zen.commit_timeout` 设定控制，默认是30秒）没有收到至少 `discovery.zen.minimum_master_nodes` 个节点的确认，集群状态的变更将被拒绝。

一旦足够的节点响应了，集群状态会被提交然后一条消息将会被发往全部节点。然后节点将继续应用新集群状态到其内部状态。主节点等待全部节点响应，直到超时，到继续处理队列中的下一个更新之前。`discovery.zen.publish_timeout` 默认设置为30秒且从发布开始的瞬间计时。两个超时设定都能通过<<cluster-update-settings,集群更新设定 api>> 进行动态变更。

[float]
[[no-master-block]]
==== 无主节点阻塞

为使集群完全可运行，必须有一个活跃主节点且运行的候选主节点数目必须满足 `discovery.zen.minimum_master_nodes` 设定。`discovery.zen.no_master_block` 设定控制无主节点时哪些操作应该被拒绝。

`discovery.zen.no_master_block` 设定有2个有效选项:

[horizontal]
`all`:: 节点上的全部操作--即是 全部读写--都被拒绝。
这也应用于集群状态的读写操作，比如获取索引设置，设定 mappings 和集群状态 api。
`write`:: （默认）写操作将被拒绝。读操作将根据上次已知的集群设置成功执行。这可能导致部分读取过时的数据因为该节点可能与集群中其他节点隔离了。

`discovery.zen.no_master_block` 设定不会应用到基于节点的 api（例如cluster stats， node info 和 node stats api）。对这些 api 的请求不会则色且能运行在任何一个有效的节点上。
