[[modules-snapshots]]
== 快照和还原

快照是从正在运行的 ElasticSearch  集群中获取的备份。你可以快照单个索引或整个集群，并将其存储在共享文件系统上的一个储藏库，并且有插件支持在 S3、HDFS、Azure、Google 云存储等上的远程储藏库。

快照是增量的。这意味着在创建索引的快照时，ElasticSearch 将避免复制任何已存储在储藏库中，作为同一索引的早期快照部分的数据。因此非常频繁地对集群进行快照也是很高效的。

快照可以通过还原 API 还原到正在运行的集群中。还原索引时，可以修改还原的索引的名称和其他一些设置，很大程度上给予快照和还原功能使用的灵活性。

WARNING: 不可能通过以下方式简单地备份 ElasticSearch 集群：复制其所有节点的数据目录。Elasticsearch 可能在运行时对它的数据目录中的内容进行更改，这意味着复制其数据目录不能确保捕获一致的内容。尝试从这样的备份去还原可能会失败，报告损坏和/或丢失的文件，或者看上去已经成功，然而悄悄地丢失了一些数据。备份集群唯一可靠的方法就是使用快照和恢复功能。

[float]
=== 版本兼容性

快照包含构成索引磁盘上的数据结构的副本。这意味着快照只能还原到可读取该索引的 ElasticSearch 版本：

* 在5.x中创建的索引快照可以还原到6.x。
* 在2.x中创建的索引快照可以还原到5.x。
* 在1.x中创建的索引快照可以还原到2.x。

相反，在1.x中创建的索引的快照 **不能** 还原到5.x或6.x，以及在2.x中创建的索引的快照 **不能** 还原到6.x。

每个快照可以包含在不同版本的 ElasticSearch 中创建的索引，当还原快照时，必须能够还原所有索引进入目标群集中。如果快照中的任何索引创建在不兼容的版本，将无法还原快照。

IMPORTANT: 在升级之前备份数据时，请记住如果快照包含创建在与升级后的版本不兼容的版本中的索引，升级后将无法还原快照。

如果您处在需要恢复索引快照，而该索引与当前运行的集群版本不兼容的情况下，
您可以在最新的兼容版本上还原它并在当前版本上使用<<reindex-from-remote,从远程重新索引>>来重建索引。
只有当原索引启用了原始数据时才能从远程重新索引。检索和重新索引数据需要花费相比于简单还原快照来说长得多的大量时间。
如果你有大量的数据，我们建议使用数据子集来测试从远程重新索引的过程，在继续之前了解所需要的时间。

[float]
=== 储藏库

在执行快照和恢复操作之前，必须先注册一个快照储藏库。建议为每个主要版本创建新的快照储藏库。有效的储藏库设置取决于储藏库类型。

如果在多个集群中注册同一个快照储藏库，则仅一个集群应该具有对储藏库的写访问权。所有其他群集连接到该储藏库时，应将储藏库设置为 `readonly` 模式。

IMPORTANT: 快照格式随着主要版本而变更，因此如果不同版本上的群集试图写入同一储藏库，由一个版本写入的快照可能对另一个版本不可见，然后储藏库会崩坏。除了一个集群外，将存储库对其他全部设置为 `readonly`，尽管这样可以工作在多个不同主要版本的集群上，但并不推荐这样配置。

[source,js]
-----------------------------------
PUT /_snapshot/my_backup
{
  "type": "fs",
  "settings": {
    "location": "my_backup_location"
  }
}
-----------------------------------
// CONSOLE
// TESTSETUP

要检索有关已注册储藏库的信息，请使用 GET 请求：

[source,js]
-----------------------------------
GET /_snapshot/my_backup
-----------------------------------
// CONSOLE

将返回:

[source,js]
-----------------------------------
{
  "my_backup": {
    "type": "fs",
    "settings": {
      "location": "my_backup_location"
    }
  }
}
-----------------------------------
// TESTRESPONSE

要检索有关多个储藏库的信息，请指定以逗号分隔的储藏库列表。当指定存储库名称时也能使用 * 通配符。
例如，以下请求检索有关以 `repo` 开头或包含 `backup` 的所有快照储藏库的信息：

[source,js]
-----------------------------------
GET /_snapshot/repo*,*backup*
-----------------------------------
// CONSOLE

要检索有关所有已注册快照储藏库的信息，请省略储藏库名称或指定 `all`:

[source,js]
-----------------------------------
GET /_snapshot
-----------------------------------
// CONSOLE

或

[source,js]
-----------------------------------
GET /_snapshot/_all
-----------------------------------
// CONSOLE

[float]
===== 共享文件系统储藏库

共享文件系统储藏库（`"typ":"fs"`）使用共享文件系统存储快照。为了注册
共享文件系统储藏库需要将相同的共享文件系统安装到主节点和数据节点相同位置。
此位置（或其父目录之一）必须在所有主节点和数据节点的 `path.repo` 设置中注册。

假设共享文件系统安装到 `/mount/backups/my_fs_backup_location`，那么以下设置应该添加到 'elasticsearch.yml' 文件：

[source,yaml]
--------------
path.repo: ["/mount/backups", "/mount/longterm_backups"]
--------------

`path.repo` 设置支持 Microsoft Windows UNC 路径，只要至少将服务器名称和共享指定为一个前缀并且反斜杠被正确转义：

[source,yaml]
--------------
path.repo: ["\\\\MY_SERVER\\Snapshots"]
--------------

重新启动所有节点后，可以使用以下命令注册名为 `my_fs_backup` 的共享文件系统储藏库：

[source,js]
-----------------------------------
PUT /_snapshot/my_fs_backup
{
    "type": "fs",
    "settings": {
        "location": "/mount/backups/my_fs_backup_location",
        "compress": true
    }
}
-----------------------------------
// CONSOLE
// TEST[skip:no access to absolute path]

如果将储藏库位置指定为相对路径，则将根据在 `path.repo` 中指定的第一个路径解析此路径：

[source,js]
-----------------------------------
PUT /_snapshot/my_fs_backup
{
    "type": "fs",
    "settings": {
        "location": "my_fs_backup_location",
        "compress": true
    }
}
-----------------------------------
// CONSOLE
// TEST[continued]

支持以下设置：

[horizontal]
`location`:: 快照的位置。强制性的。
`compress`:: 开启快照文件的压缩。压缩仅应用于元数据文件（索引映射和设置）。数据文件未压缩。默认为 `true`。
`chunk_size`:: 如果需要，可以在快照期间将大文件分解成块。块大小可以用字节或使用大小值表示法，即1g、10m、5k。默认为 `null`（块大小不受限制）。
 `max_restore_bytes_per_sec`:: 每节点还原速率的限制。默认为每秒 `40mb`。
`max_snapshot_bytes_per_sec`:: 每节点快照速率的限制。默认为每秒 `40mb`。
`readonly`:: 使储藏库为只读。默认为 `false`。

[float]
===== 只读URL储藏库

URL存储库（`“type”：“url”`）可用作访问由共享文件系统储藏库创建的数据的另一种只读方式。
`url`参数中指定的 URL 应指向共享文件系统储藏库的根目录。支持以下设置：

[horizontal]
`url`:: 快照的位置。强制性的。

URL 储藏库支持以下协议：“http”、“https”、“ftp”、“file”和“jar”。URL 储藏库包含 `http:`，`https:`，和 `ftp:` URLs 必须在 `repositories.url.allowed_urls` 设置中指定的允许的 URLs 白名单中。此设置支持在主机、路径、查询和片段位置使用通配符。例如：

[source,yaml]
-----------------------------------
repositories.url.allowed_urls: ["http://www.example.org/root/*", "https://*.mydomain.com/*?*#*"]
-----------------------------------

URL 储藏库包含 `file:` URLs 只能指向在 `path.repo` 设置中注册的位置，类似于共享文件系统储藏库。

[float]
[role="xpack"]
[testenv="basic"]
===== 仅源储藏库

源储藏库使您能够创建占用磁盘空间最多减少50%的仅限源的最小快照。仅源快照包含存储字段和索引元数据。它们不包括索引或文档值结构并且在还原时不可搜索。还原仅源快照后，必须<<docs reindex，重新索引>>数据到一个新索引。

源储藏库委托给另一个快照储藏库进行存储。

[IMPORTANT]
==================================================

只有启用了 `_source` 字段且未应用源筛选时，才支持仅源快照。还原仅源快照时：

 * 还原的索引是只读的，且只能用于 `match_all` 搜索或滚动请求以启用重新索引。

 * 不支持 `match_all` 和 `_get` 请求以外的查询。

 * 还原索引的映射为空，但原始映射可从类型顶部级别的 `meta` 元素获得。

==================================================

创建源储藏库时，必须指定代理储藏库的类型和名称存储快照的位置：

[source,js]
-----------------------------------
PUT _snapshot/my_src_only_repository
{
  "type": "source",
  "settings": {
    "delegate_type": "fs",
    "location": "my_backup_location"
  }
}
-----------------------------------
// CONSOLE
// TEST[continued]

[float]
===== 储藏库插件

这些官方插件中还提供了其他储藏库后端：

* {plugins}/repository-s3.html[repository-s3]支持 S3 储藏库
* {plugins}/repository-hdfs.html[repository-hdfs] 支持 Hadoop 环境中的 HDFS 储藏库
* {plugins}/repository-azure.html[repository-azure]用于 Azure 存储储藏库
* {plugins}/repository-gcs.html[repository-gcs]]用于 Google 云存储储藏库

[float]
===== 储藏库验证

当一个存储库被注册时，它会立即在所有的主节点和数据节点上进行验证，以确保它的功能在群集中当前存在的所有节点上正常。`verify` 参数可用于显式禁用注册或更新储藏库时的储藏库验证：

[source,js]
-----------------------------------
PUT /_snapshot/my_unverified_backup?verify=false
{
  "type": "fs",
  "settings": {
    "location": "my_unverified_backup_location"
  }
}
-----------------------------------
// CONSOLE
// TEST[continued]

也可以运行以下命令手动执行验证过程：

[source,js]
-----------------------------------
POST /_snapshot/my_unverified_backup/_verify
-----------------------------------
// CONSOLE
// TEST[continued]

它返回储藏库成功验证了的节点列表或者验证过程失败时返回一个错误信息。

[float]
=== 快照

储藏库可以包含同一集群的多个快照。快照由集群中的唯一名称标志。通过执行以下命令，可以在储藏库 `my_backup` 中创建名为 `snapshot_1` 的快照：

[source,js]
-----------------------------------
PUT /_snapshot/my_backup/snapshot_1?wait_for_completion=true
-----------------------------------
// CONSOLE
// TEST[continued]

`wait_for_completion` 参数指定请求是否应在快照初始化后立即返回（默认）或等待快照完成。在快照初始化期间，有关所有以前的快照的信息被加载到内存中，这意味着在大型储藏库中,即使  `wait_for_completion` 参数设置为 `false`，命令返回也可能需要花几秒钟（甚至几分钟）。

默认情况下，将创建集群中所有打开和启动的索引的快照。可以通过指定快照请求正文中的索引列表来改变快照行为。

[source,js]
-----------------------------------
PUT /_snapshot/my_backup/snapshot_2?wait_for_completion=true
{
  "indices": "index_1,index_2",
  "ignore_unavailable": true,
  "include_global_state": false
}
-----------------------------------
// CONSOLE
// TEST[continued]

应包含在快照中的索引列表可以使用 `indices` 参数来指定，它支持<<multi-index,多索引语法>>。快照请求还支持 `ignore_unavailable` 选项。将其设置为 `true` 将导致在创建快照期间忽略不存在的索引。默认情况下，如果未设置 `ignore_unavailable` 选项并且缺少索引，则快照请求将失败。通过将 `include_global_state` 设置为false，可以防止将群集全局状态作为快照的一部分存储。默认情况下，如果参与快照的一个或多个索引并非所有主分片可用，整个快照将会失败。通过将 `partial` 设置为 `true` 可以更改此行为。

快照名称可以使用<<date-math-index-names,日期计算表达式>>自动派生，与创建新索引时类似。请注意，特殊字符需要进行 URI 编码。

例如，可以使用以下命令创建名字中有当前日期，如 `snapshot-2018.05.11`，的快照：

[source,js]
-----------------------------------
# PUT /_snapshot/my_backup/<snapshot-{now/d}>
PUT /_snapshot/my_backup/%3Csnapshot-%7Bnow%2Fd%7D%3E
-----------------------------------
// CONSOLE
// TEST[continued]


索引快照过程是增量的。在进行索引快照的过程中，Elasticsearch 分析中已存储在储藏库中的索引文件列表，然后仅复制自上次快照以来创建的或变更的文件。这使得在储藏库中可以紧凑的形式保留多个快照。快照过程以非阻塞方式执行。所有索引和搜索操作都可以继续对正在快照的索引执行。但是，快照表示的是索引在快照创建时刻的时间点视图因此在快照进程启动后添加到索引中的记录将不会出现在快照中。对于已启动的，且不处于迁移中的主分片，快照进程立即启动。在版本1.2.0之前，如果集群中有任何正在迁移或初始化的参与快照的索引的主分片，快照操作将失败。从1.2.0版开始，ElasticSearch 会等待迁移或初始化的主分片完成再开始快照。

除了创建每个索引的副本之外，快照进程还可以存储全局集群元数据，其中包括持久性群集设置和模板。临时设置和已注册的快照储藏库不作为快照部分存储。

在集群中，任何时候只能执行一个快照进程。当特定分片的快照创建时，此分片不能移动到另一个节点，这会影响再平衡过程和分配过滤。只有当快照结束时，Elasticsearch 才只能将分片移动到另一个节点（根据当前分配过滤设置和再平衡算法）。

创建快照后，可以使用以下命令获取有关此快照的信息：

[source,sh]
-----------------------------------
GET /_snapshot/my_backup/snapshot_1
-----------------------------------
// CONSOLE
// TEST[continued]

此命令返回有关快照的基本信息，包括开始和结束时间、创建快照的 Elasticsearch 的版本、包含索引的列表、
快照当前状态和快照期间发生的故障列表。快照 `state` 可以是

[horizontal]
`IN_PROGRESS`::

  快照正在运行。

`SUCCESS`::

  快照结束并且全部分片都成功存储。

`FAILED`::

  快照以错误和存储任何数据失败而结束。

`PARTIAL`::

  已存储全局群集状态，但至少一个分片的数据未成功存储。这种情况下，`failure` 部分应包含没有正确处理的有关碎片的更详细信息。

`INCOMPATIBLE`::

  快照是用旧版本的 Elasticsearch 创建的，因此与群集的当前版本不兼容。


与储藏库类似，可以一次查询多个快照的信息，还支持通配符：

[source,sh]
-----------------------------------
GET /_snapshot/my_backup/snapshot_*,some_other_snapshot
-----------------------------------
// CONSOLE
// TEST[continued]

可以使用以下命令列出储藏库中当前存储的所有快照：

[source,sh]
-----------------------------------
GET /_snapshot/my_backup/_all
-----------------------------------
// CONSOLE
// TEST[continued]

如果某些快照不可用，则该命令将失败。布尔参数 `ignore_unavailable` 用于返回当前可用的所有快照。

在基于云的储藏库中，获取储藏库中的所有快照，从成本和性能的角度来看可能代价高昂。如果唯一需要的信息是储藏库中的快照名称/uuid 和每个快照中的索引，那么可选的布尔参数 `verbose` 可以设置为 `false` 以更好的性能和效率来检索储藏库中的快照。注意，将 `verbose` 设置为 `false` 将忽略有关快照的所有其他信息例如状态信息、快照分片的数量等。`verbose` 参数的默认值为 `true`。

可以使用以下命令检索当前正在运行的快照：

[source,sh]
-----------------------------------
GET /_snapshot/my_backup/_current
-----------------------------------
// CONSOLE
// TEST[continued]

可以使用以下命令从储藏库中删除快照：

[source,sh]
-----------------------------------
DELETE /_snapshot/my_backup/snapshot_2
-----------------------------------
// CONSOLE
// TEST[continued]

从储藏库中删除快照时，Elasticsearch 将删除与已删除的快照相关联的，不由任何其他快照使用的全部文件。如果在快照被创建时执行删除快照的操作，快照过程将中止，作为快照过程一部分所创建的所有文件将清除。因此，可以使用删除快照操作取消因失误开始的长时间运行的快照操作。

可以使用以下命令注销储藏库：

[source,sh]
-----------------------------------
DELETE /_snapshot/my_backup
-----------------------------------
// CONSOLE
// TEST[continued]

当储藏库注销时，Elasticsearch 只删除对储藏库存储快照的位置的引用。快照本身保持原样。

[float]
=== 还原

可以使用以下命令还原快照

[source,sh]
-----------------------------------
POST /_snapshot/my_backup/snapshot_1/_restore
-----------------------------------
// CONSOLE
// TEST[continued]

默认将还原快照中的所有索引，且群集状态 *不会* 还原。可以在还原请求正文中包含 `indices` 和 `include_global_state` 选项，来选择应该还原的索引以及允许还原全局群集状态。索引列表支持<<multi-index,多索引语法>>。`rename_pattern` 模式和 `rename_replacement` 选项也可用于在还原时使用支持引用原始文本的正则表达式（ http://docs.oracle.com/javase/6/docs/api/java/util/regex/Matcher.html#appendReplacement(java.lang.StringBuffer,%20java.lang.String)[此]）来重命名索引。

将 `include_aliases` 设置为 `false` 以防止别名与相关索引一起还原。

[source,js]
-----------------------------------
POST /_snapshot/my_backup/snapshot_1/_restore
{
  "indices": "index_1,index_2",
  "ignore_unavailable": true,
  "include_global_state": true,
  "rename_pattern": "index_(.+)",
  "rename_replacement": "restored_index_$1"
}
-----------------------------------
// CONSOLE
// TEST[continued]

可以在正常工作的群集上执行还原操作。然而，对于已经存在的索引，只有处于<<indices-open-close,关闭>>状态且与快照中的索引具有相同数量的分片时，才可以还原。如果被还原的索引处于关闭状态或不存在于集群，还原操作将自动打开或创建索引。如果使用 `include_global_state`（默认为 `false`）还原集群状态，当前不存在于群集中的还原的模板将被添加，而已经存在的同名模板将被替换为还原的模板。被还原的持久设置将添加到现有的持久设置中。

[float]
==== 部分还原

默认情况下，如果参与还原操作的一个或多个索引不包含全部可用分片的快照，整个还原操作将会失败。例如，如果某些分片快照失败，则可能发生这种情况。但仍然可以通过将 `partial` 设置为 `true` 来还原此类索引。请注意，这种情况下，只有成功快照的分片才会被还原，所有丢失的分片将重新创建为空。

[float]
==== 还原期间更改索引设置

在还原过程中，可以覆盖大多数索引设置。例如，以下命令将还原 `index_1`，且不包含任何副本，同时调整刷新间隔到默认值：

[source,js]
-----------------------------------
POST /_snapshot/my_backup/snapshot_1/_restore
{
  "indices": "index_1",
  "index_settings": {
    "index.number_of_replicas": 0
  },
  "ignore_index_settings": [
    "index.refresh_interval"
  ]
}
-----------------------------------
// CONSOLE
// TEST[continued]

请注意，某些设置，如`index.number_of_shards` 在还原操作期间无法更改。

[float]
==== 还原到其他群集

快照中存储的信息没有绑定到特定的集群或集群名称。因此可以将从一个集群生成的快照还原到另一个群集。唯一需要的就是在新集群中注册包含快照的储藏库并启动还原过程。新集群不需要拥有相同的大小或拓扑结构。但是，新集群的版本应该与创建快照的集群的版本相同或更新（只有1个主要版本差别）。例如，可以将1.x快照还原到2.x群集，但不能将1.x快照还原到5.x群集。

如果新集群的大小较小，则应多加考虑。首先要确保这个新集群有足够的容量来存储快照中的所有索引。在还原过程中可以更改索引设置减少副本的数量，这有助于将快照还原到较小的集群中。也能使用 `indices` 参数选择索引的子集。

如果原始集群中的索引使用<<shard-allocation-filtering,分片分配过滤>>指定了特定的节点，相同的规则将在新集群中强制执行。因此如果新集群不包含具有可在其上分配还原索引的适当属性的节点，除非在还原操作期间更改了这些索引分配设置，否则将无法成功还原这些索引。

还原操作还检查还原的持久设置是否与当前集群兼容，以避免意外地还原不兼容的设置，如 `discovery.zen.minimum_master_nodes` 还原到小集群中而导致集群瘫痪，直到添加所需的候选主节点数为止。如果需要还原包含不兼容的持久设置的快照，请尝试不包含全局群集状态来还原它。

[float]
=== 快照状态

可以使用以下命令获取当前正在运行的快照及其详细状态信息的列表：

[source,sh]
-----------------------------------
GET /_snapshot/_status
-----------------------------------
// CONSOLE
// TEST[continued]

在这种格式下，命令将返回有关当前运行的所有快照的信息。通过指定储藏库名称，可以将结果限制到特定的储藏库：

[source,sh]
-----------------------------------
GET /_snapshot/my_backup/_status
-----------------------------------
// CONSOLE
// TEST[continued]

如果同时指定了储藏库名称和快照ID，则此命令将返回给定快照的详细状态信息，即使它当前没有运行：

[source,sh]
-----------------------------------
GET /_snapshot/my_backup/snapshot_1/_status
-----------------------------------
// CONSOLE
// TEST[continued]

输出类似于以下内容：

[source,js]
--------------------------------------------------
{
  "snapshots": [
    {
      "snapshot": "snapshot_1",
      "repository": "my_backup",
      "uuid": "XuBo4l4ISYiVg0nYUen9zg",
      "state": "SUCCESS",
      "include_global_state": true,
      "shards_stats": {
        "initializing": 0,
        "started": 0,
        "finalizing": 0,
        "done": 5,
        "failed": 0,
        "total": 5
      },
      "stats": {
        "incremental": {
          "file_count": 8,
          "size_in_bytes": 4704
        },
        "processed": {
          "file_count": 7,
          "size_in_bytes": 4254
        },
        "total": {
          "file_count": 8,
          "size_in_bytes": 4704
        },
        "start_time_in_millis": 1526280280355,
        "time_in_millis": 358,

        "number_of_files": 8,
        "processed_files": 8,
        "total_size_in_bytes": 4704,
        "processed_size_in_bytes": 4704
      }
    }
  ]
}
--------------------------------------------------
// TESTRESPONSE

输出由不同的部分组成。`stats` 子对象提供了有关快照的文件的数量和大小的详情。由于快照是增量的，只复制储藏库中不存在的 Lucene 段，`stats` 对象包含快照引用的所有文件的 `total` 部分，以及那些实际上需要作为增量快照的一部分而复制的文件的 `incremental` 部分。。若快照仍然在进行中，还有一个 `processed` 部分，其中包含正在复制的文件的信息。

_Note_: `number_of_files`、`processed_files`、`total_size_in_bytes` 和 `processed_size_in_bytes` 属性用于旧版本5.x和6.x的向后兼容性。这些字段将在 Elasticsearch v7.0.0中删除。

还支持多个id：

[source,sh]
-----------------------------------
GET /_snapshot/my_backup/snapshot_1,snapshot_2/_status
-----------------------------------
// CONSOLE
// TEST[continued]

[float]
=== 监控快照/还原进度

在它们运行时有几种方法可以监控快照和还原的进度。两个操作都支持 `wait_for_completion` 参数，该参数将阻塞客户端，直到操作完成。这是可用于获得有关操作完成的通知的最简单的方法。

还可以通过定期调用快照信息来监视快照操作：

[source,sh]
-----------------------------------
GET /_snapshot/my_backup/snapshot_1
-----------------------------------
// CONSOLE
// TEST[continued]

请注意，快照信息操作使用的资源和线程池与快照操作相同。所以，在快照大分片时执行快照信息操作可能导致快照信息操作在返回结果之前等待可用资源。对于非常大的分片，等待时间可能很长。

要更快地获得关于快照更完整的信息，可以使用快照状态命令：

[source,sh]
-----------------------------------
GET /_snapshot/my_backup/snapshot_1/_status
-----------------------------------
// CONSOLE
// TEST[continued]

快照信息方法只返回正在进行的快照的基本信息，而快照状态将返回每个参与快照的分片的当前状态的完全细分。

还原过程依附于 Elasticsearch 的标准恢复机制。因此，标准恢复监控服务可用于监控还原状态。执行还原操作时，群集通常会进入 `red` 状态。发生这种情况是因为还原操作从“恢复”被还原索引的主分片开始。在此操作过程中，主分片将不可用，使集群处于 `red` 状态。一旦主分片恢复完成，Elasticsearch 将切换到标准的副本过程，此时创建所需数量的副本同时集群切换到 `yellow` 状态。一旦所有必需的副本创建后，集群将切换到 `green` 状态。

集群健康操作仅提供还原进程的高级状态。通过使用<<indices-recovery,索引恢复>>和<<cat-recovery,查看恢复>> API，可以洞察到更多恢复过程的当前状态的详细信息。

[float]
=== 停止当前正在运行的快照和还原操作

快照和还原框架一次只允许运行一个快照或还原操作。如果当前运行的快照是错误执行的，或者花费了异常长的时间，可以使用快照删除操作终止快照。
快照删除操作检查删除的快照当前是否正在运行，如果正在运行，则删除操作删除储藏库中的快照数据之前会先停止快照。

[source,sh]
-----------------------------------
DELETE /_snapshot/my_backup/snapshot_1
-----------------------------------
// CONSOLE
// TEST[continued]

还原操作使用标准的分片恢复机制。因此，当前运行的任何还原操作都可以通过删除正在还原的索引来取消。请注意，此操作的结果是清除集群中所有被删除索引的数据。

[float]
=== 集群阻塞对快照和还原操作的影响
许多快照和还原操作都受集群和索引阻塞的影响。例如，注册和注销储藏库需要全局元数据的写权限。快照操作要求所有索引及其元数据以及全局元数据是可读的。还原操作要求全局元数据可写，然而在还原期间会忽略索引级阻塞，因为在还原期间基本上重新创建了索引。请注意，储藏库内容不是集群的一部分，因此集群阻塞不会影响内部储藏库操作，如从已注册的储藏库中列出或删除快照。
