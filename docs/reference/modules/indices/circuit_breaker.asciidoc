[[circuit-breaker]]
=== 断路器

ElasticSearch 包含多个断路器，用于防止操作导致的内存不足错误。每个断路器都指定它可以使用的内存大小限制。此外，还有一个父级断路器指定所有断路器使用的内存总量。

这些设置可以在活跃群集上使用 <<cluster-update-settings,集群更新设定>> API 来动态更新。

[[parent-circuit-breaker]]
[float]
==== 父断路器

父级断路器可用以下设定来配置：

`indices.breaker.total.limit`::

    开启全部父断路器的限制，默认为 JVM 堆的 70%。

[[fielddata-circuit-breaker]]
[float]
==== 字段数据断路器

字段数据断路器允许 ElasticSearch 估计字段需要加载到内存中的所需内存。它可以通过提出一个异常来防止加载字段数据。默认情况下，该限制配置为最大 JVM 堆的 60%。它可用如下参数配置：

`indices.breaker.fielddata.limit`::

    字段数据断路器的限制，默认为 JVM 对的 60%。

`indices.breaker.fielddata.overhead`::

    字段数据预估的乘数因子，用来决定最终评估的内存大小的常数。默认为 1.03。

[[request-circuit-breaker]]
[float]
==== 请求断路器

请求断路器允许 ElasticSearch 阻止每个请求数据结构超过一定的内存量（例如，一个请求中用来计算聚合的内存）。

`indices.breaker.request.limit`::

    请求断路器的限制，默认为 JVM 堆的60%

`indices.breaker.request.overhead`::

    一个常量，所有请求估算值都与该常量相乘以确定最终估算值。默认为1

[[in-flight-circuit-breaker]]
[float]
==== 飞行中（In flight）请求断路器

飞行中请求断路器允许 ElasticSearch 限制所有当前在传输或 HTTP 层上的活动的传入请求，防止超过一个节点上的一定数量的内存。内存使用量基于请求本身的内容长度。

`network.breaker.inflight_requests.limit`::

    飞行请求中断器的限制，默认为 JVM 堆的100%。这意味着它受制于父断路器配置的限制。

`network.breaker.inflight_requests.overhead`::

    一个常数，所有飞行中的请求估算值与之相乘，以确定最终估算值。默认值为1

[[accounting-circuit-breaker]]
[float]
==== 计数请求断路器Accounting requests circuit breaker

计数断路器允许 ElasticSearch 限制当请求完成时仍被内存持有的不会被释放的内存使用。这包括 Lucene 段内存等。

`indices.breaker.accounting.limit`::

    计数断路器的限制，默认为 JVM 堆的100%。这意味着它受制于父断路器配置的限制。

`indices.breaker.accounting.overhead`::

    一个常数，所有计数估算值与之相乘，以确定最终估算值。默认值为1

[[script-compilation-circuit-breaker]]
[float]
==== 脚本编译断路器

与之前基于内存的断路器略有不同，脚本编译断路器限制在一段时间内行内脚本编译的数量。

请参阅<<modules-scripting-using,脚本>>文档中的“首选参数”部分以获取更多信息。

`script.max_compilations_rate`::

    特定间隔内唯一动态脚本被允许编译的数量限制。默认为75/5m，即每5分钟75个。
