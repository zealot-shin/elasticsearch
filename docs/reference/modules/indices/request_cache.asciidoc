[[shard-request-cache]]
=== 分片请求缓存Shard request cache

当对一个索引或多个索引运行搜索请求时，每个相关的分片在本地执行搜索并将其本地结果返回到 _协调_ 节点，协调节点将这些分片级别的结果组合成 ``全局`` 结果集。

分片级别请求缓存模块缓存每个分片上的本地结果。这使得频繁使用的（可能很重的）搜索请求可立即返回结果。请求缓存非常适合日志记录用例，其中只有最新的索引处于活跃的更新状态--旧索引的结果将直接从缓存中提供。

[IMPORTANT]
===================================

默认情况下，请求缓存将只缓存 `size=0` 的搜索请求的结果，因此不会缓存 `hits`，但它将缓存 `hits.total`，<<search-aggregations,聚合>>，以及<<search-suggesters,建议>>。

大多数使用 `now`（请参见 <<date-math>>）的查询都无法缓存。

===================================

[float]
==== 缓存失效Cache invalidation

缓存是智能的——同为缓存的搜索一样，它保持近实时的承诺。

缓存结果在分片刷新时自动失效，但只在分片中的数据实际发生更改时。换句话说，你会
始终从缓存中获取与未缓存的搜索请求相同的结果。

刷新间隔越长，缓存项将保留的有效时间越长。如果缓存已满，则最近使用的缓存键将为被驱逐。

可以使用<<indices-clearcache,`清楚缓存` API>> 手动过期缓存：

[source,js]
------------------------
POST /kimchy,elasticsearch/_cache/clear?request=true
------------------------
// CONSOLE
// TEST[s/^/PUT kimchy\nPUT elasticsearch\n/]

[float]
==== 启用和禁用缓存

默认是启用缓存的，但创建新索引时可以禁用，如下所示：

[source,js]
-----------------------------
PUT /my_index
{
  "settings": {
    "index.requests.cache.enable": false
  }
}
-----------------------------
// CONSOLE

也可以使用<<indices-update-settings,`更新设置`>> API 在一个已经存在的索引上动态地启用或禁用：

[source,js]
-----------------------------
PUT /my_index/_settings
{ "index.requests.cache.enable": true }
-----------------------------
// CONSOLE
// TEST[continued]


[float]
==== 每个请求启用和禁用缓存

查询字符串参数中的 `request_cache` 可用来在 *每个请求* 的基础上启用或禁用缓存。若设置的话，它会覆盖索引级别的设置：

[source,js]
-----------------------------
GET /my_index/_search?request_cache=true
{
  "size": 0,
  "aggs": {
    "popular_colors": {
      "terms": {
        "field": "colors"
      }
    }
  }
}
-----------------------------
// CONSOLE
// TEST[continued]

IMPORTANT: 若查询使用了一个脚本，脚本结果不是确定性的（例如，使用了随机函数或引用了当前时间），就该把 `request_cache` 参数设置为 `false` 来对该请求禁用缓存。

`size` 大于 0 的请求不会缓存，即便在索引设置中启用了请求缓存。要缓存这些请求，需要使用此处说明的查询字符串参数。

[float]
==== 缓存键

把整个 JSON 体用作缓存键。这意味着如果 JSON 改变 -- 比如键用不同的顺序输出 -- 那么缓存键就无法被识别。
The whole JSON body is used as the cache key.  This means that if the JSON
changes -- for instance if keys are output in a different order -- then the
cache key will not be recognised.

TIP: 多数 JSON 库都支持一个 _规范_ 模式，以确保 JSON 键总是以相同的顺序发出。此规范模式可用于应用程序，以确保请求始终以相同的方式序列化。

[float]
==== 缓存设置

缓存是在节点级别进行管理的，并且有一个默认的最大值为堆的 `1%`。可在 `config/elasticsearch.yml` 中使用以下设置来改变：

[source,yaml]
--------------------------------
indices.requests.cache.size: 2%
--------------------------------

并且，也可以使用 +indices.requests.cache.expire+ 设置来指定缓存结果的 TTL，但应该没必要这么做。
记住，陈旧的结果在索引刷新的时候会自动失效。该设置仅是出于完整性而提供的。

[float]
==== 监控缓存使用

利用<<indices-stats,`索引统计`>> API，可查看索引的缓存大小（字节）和驱逐的数量：

[source,js]
------------------------
GET /_stats/request_cache?human
------------------------
// CONSOLE

或使用<<cluster-nodes-stats,`节点统计`>> API 来看节点的：

[source,js]
------------------------
GET /_nodes/stats/indices/request_cache?human
------------------------
// CONSOLE
